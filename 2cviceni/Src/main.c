/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f0xx.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define LED_TIME_BLINK 300 // preprocessor replaces LED_TIME_BLINK with number 300
#define LED_TIME_SHORT 100 // preprocessor replaces LED_TIME_SHORT with number 100
#define LED_TIME_LONG 1000 // preprocessor replaces LED_TIME_LONG with number 1000
#define SAMPLE_TIME 40 // preprocessor replaces SAMPLE_TIME with number 40
#define DEBOUNCE_TIME 5 // preprocessor replaces SAMPLE_TIME with number 5

volatile uint32_t Tick; // global variable

void blikac(void)// this function is non-blockative counter for LED_TIME_BLINK ms
{
	static uint32_t delay;

	if (Tick > delay + LED_TIME_BLINK) {
		GPIOA->ODR ^= (1<<4); // reads value of LED1  and toggle LED1s value
		delay = Tick;
	}
}

void tlacitka(){ // non/blocking function for reading buttons S1 and S2 and switching on LED2 for 1000 ms (S1) or 100 ms (S2)
	/* !!!! COMMENTED BECAUSE OF COLLISION WITH TASK 5, HOWEVER THIS TYPE OF SAMPLING IS GOOD ENOUGH IN MOST APLICATIONS !!!!
	static uint32_t old_s1;
	static uint32_t old_s2;
	static uint32_t off_time;
	static uint32_t stop_sample;
	uint32_t new_s2;
	uint32_t new_s1;

	Sampling buttons every 40 ms
	if (Tick > stop_sample){
		new_s2 = GPIOC->IDR & (1<<0); // S2
		new_s1 = GPIOC->IDR & (1<<1); // S1
		stop_sample = Tick + SAMPLE_TIME;
	}

	if (old_s2 && !new_s2) { // falling edge
		off_time = Tick + LED_TIME_SHORT;
		GPIOB->BSRR = (1<<0);
	}
	old_s2 = new_s2;

	if (old_s1 && !new_s1) { // falling edge
		off_time = Tick + LED_TIME_LONG;
		GPIOB->BSRR = (1<<0);
	}
	old_s1 = new_s1;

	if (Tick > off_time) { // switches LED2 off when the time is right
		GPIOB->BRR = (1<<0);
	}*/

	// TASK 5
	static uint32_t off_time;
	static uint32_t stop_sample;
	static uint16_t debounce_s2;
	static uint16_t debounce_s1;

	//Sampling buttons every 5 ms
	if (Tick > stop_sample){
		debounce_s1 <<= 1;
		if (GPIOC->IDR & (1<<1)){ // if button S1 has value 1, set debounce_s1 LSB to 1
			debounce_s1 |= 0x0001;
		}

		debounce_s2 <<= 1;
		if (GPIOC->IDR & (1<<0)){ // if button S2 has value 1, set debounce_s2 LSB to 1
			debounce_s2 |= 0x0001;
		}
		stop_sample = Tick + DEBOUNCE_TIME;
	}

	if (debounce_s2 == 0x8000) { // if debounce_s2 indicates no more zakmitu 0b10000000000000000000
		off_time = Tick + LED_TIME_SHORT;
		GPIOB->BSRR = (1<<0);
		debounce_s2 = 0xFFFF;
	}

	if (debounce_s1 == 0x8000) { // if debounce_s1 indicates no more zakmitu 0b10000000000000000000
		off_time = Tick + LED_TIME_LONG;
		GPIOB->BSRR = (1<<0);
		debounce_s1 = 0xFFFF;
	}

	if (Tick > off_time) { // switches LED2 off when the time is right
		GPIOB->BRR = (1<<0);
	}
}

int main(void)
{
	/*Setting clock pins*/
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOBEN | RCC_AHBENR_GPIOCEN; // enable clock GPIOA,B,C
    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN; // SYSCFG clock enable

    /*Setting GPIO pins*/
    GPIOA->MODER |= GPIO_MODER_MODER4_0; // LED1 = PA4, output
    GPIOB->MODER |= GPIO_MODER_MODER0_0; // LED2 = PB0, output
    GPIOC->PUPDR |= GPIO_PUPDR_PUPDR0_0; // S2 = PC0, pull-up
    GPIOC->PUPDR |= GPIO_PUPDR_PUPDR1_0; // S1 = PC1, pull-up

    /*Definitions for interrupt !!!! COMMENTED BECAUSE OF OVERLAPING BUTTON S2 WITH TASK 4 !!!!*/
//    SYSCFG->EXTICR[0] |= SYSCFG_EXTICR1_EXTI0_PC; // select PC0 for EXTI0
//    EXTI->IMR |= EXTI_IMR_MR0; // mask
//    EXTI->FTSR |= EXTI_FTSR_TR0; // trigger on falling edge
//    NVIC_EnableIRQ(EXTI0_1_IRQn); // enable EXTI0_1

    /*Turning shields LED1 and LED2 on*/
    GPIOA->BSRR = (1<<4); // set LED1
    GPIOB->BSRR = (1<<0); // set LED2

    /*Setting tick frequency 8MHz core*/
    SysTick_Config(8000); // 1ms

    while (1) {
    	blikac(); // calling function for non-blockative counter
    	tlacitka(); // calling function for non-blockative counter
    }
}
// !!!! COMMENTED BECAUSE OF OVERLAPING BUTTON S2 WITH TASK 4 !!!!
//void EXTI0_1_IRQHandler(void)
//{
//    if (EXTI->PR & EXTI_PR_PR0) { // check line 0 has triggered the IT
//    	EXTI->PR |= EXTI_PR_PR0; // clear the pending bit
//    	GPIOB->ODR ^= (1<<0); // reads value of LED2  and toggle LED2s value
//
//    }
//}
void SysTick_Handler(void){
	Tick++; // important handler
}

